import{_ as e,o as s,c as a,Q as n}from"./chunks/framework.477046d0.js";const h=JSON.parse('{"title":"Приложение: Миграция с Vue 2","description":"","frontmatter":{"head":[["meta",{"name":"og:site_name","content":"Vue.js 3 Design Patterns and Best Practices"}],["meta",{"name":"og:image","content":"/images/book-face.jpg"}],["meta",{"name":"twitter:image","content":"/images/book-face.jpg"}]]},"headers":[],"relativePath":"book/ru/Appendix__Migrating_from_Vue_2.md","filePath":"book/ru/Appendix__Migrating_from_Vue_2.md"}'),o={name:"book/ru/Appendix__Migrating_from_Vue_2.md"},t=n(`<h1 id="приложение-миграция-с-vue-2" tabindex="-1">Приложение: Миграция с Vue 2 <a class="header-anchor" href="#приложение-миграция-с-vue-2" aria-label="Permalink to &quot;Приложение: Миграция с Vue 2&quot;">​</a></h1><p>Переход приложения Vue 2 на Vue 3 не так прост, как простая замена фреймворка. Хотя API Options остается полностью совместимым, и нет необходимости переходить на API Composition, есть и другие изменения, о которых следует знать.</p><p>В Vue 2 есть и другие изменения.</p><p>Изменения между версиями затрагивают не только основной фреймворк, но и экосистему (новый маршрутизатор, управление состояниями и т.д.), а также другие зависимости. В Vue 3 также появился новый официальный бандлер <strong>Vite</strong> (заменяющий <strong>WebPack</strong>), новый маршрутизатор и управление состоянием (<strong>Pinia</strong>, замена <strong>Vuex</strong>), а также другие плагины. Приведенный здесь список изменений является кратким справочником, который поможет вам в миграции вашего приложения, но не может быть исчерпывающим с учетом всех нюансов, необходимых для каждого конкретного проекта. В связи с этим я отсылаю вас к официальной документации по миграции на сайте <a href="https://v3-migration.vuejs.org/" target="_blank" rel="noreferrer"><span class="No-Break">https://v3-migration.vuejs.org/</span></a></p><p>.</p><p>Здесь приведен неполный список основных изменений, помимо нового Composition API:</p><ul><li>Иной способ загрузки и запуска приложения</li><li>Изменения в регистрации глобальных компонентов и плагинов</li><li>Изменения в свойстве <strong>data</strong></li><li>Изменения в <strong>v-model</strong>, <strong>props</strong> и <strong>emits</strong></li><li>Варианты реактивности</li><li>Совместимость с браузерами</li><li>Изменения в организации каталогов и файлов</li><li>Изменения в маршрутизаторе и управлении состояниями</li></ul><p>Этот список не показывает всех изменений <em>под капотом</em>, через которые прошел фреймворк, но он даст вам отправную точку для миграции вашего рабочего приложения с Vue 2 на Vue 3. Теперь давайте рассмотрим каждый из этих пунктов более подробно.</p><h2 id="другои-способ-загрузки-и-запуска-приложения" tabindex="-1">Другой способ загрузки и запуска приложения <a class="header-anchor" href="#другои-способ-загрузки-и-запуска-приложения" aria-label="Permalink to &quot;Другой способ загрузки и запуска приложения&quot;">​</a></h2><p>.</p><p>Изменился способ загрузки и запуска нашего приложения. Теперь требуется импортировать конструктор из пакета Vue. Давайте сравним обе реализации из <span class="No-Break"><strong>main.js</strong></span></p><p>:</p><p><strong>Vue 2</strong> <strong>инстанцирование приложения</strong></p><p>:</p><div class="language-source-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">source-code</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">import Vue from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">const app=new Vue({el: &quot;#app&quot;})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">import Vue from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#24292e;">const app=new Vue({el: &quot;#app&quot;})</span></span></code></pre></div><p>.</p><p>В Vue 2 мы импортируем конструктор Vue и передаем объект с опциями. В Vue 3 после создания приложения мы подключаем компоненты, плагины и т.д., а затем монтируем наше приложение к компоненту верхнего уровня. Вот пример, переписанный для Vue 3:</p><p><strong>Vue 3</strong> <strong>инстанцирование приложения</strong></p><p>:</p><div class="language-source-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">source-code</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">import {createApp} from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">const app=createApp({..})</span></span>
<span class="line"><span style="color:#e1e4e8;">app.mount(&quot;#app&quot;)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">import {createApp} from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#24292e;">const app=createApp({..})</span></span>
<span class="line"><span style="color:#24292e;">app.mount(&quot;#app&quot;)</span></span></code></pre></div><p>Положение файла <strong>index.html</strong> также изменилось, и теперь он располагается в корне нашего приложения. Более подробно изменения в структуре документа описаны в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079" target="_blank" rel="noreferrer"><em>главе 3</em></a>, <em>Setting Up a</em> <span class="No-Break"><em>Working Project</em></span><span class="No-Break">. </span></p><h2 id="регистрация-глобальных-компонентов-плагинов-и-так-далее" tabindex="-1">Регистрация глобальных компонентов, плагинов и так далее <a class="header-anchor" href="#регистрация-глобальных-компонентов-плагинов-и-так-далее" aria-label="Permalink to &quot;Регистрация глобальных компонентов, плагинов и так далее&quot;">​</a></h2><p>.</p><p>В Vue 2 мы объявляем компонент для всего приложения (глобальный), прикрепляя его к корневому экземпляру Vue. Вот пример:</p><div class="language-source-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">source-code</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">import Vue from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">import MyComponent from &quot;MyComponent.vue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">vue.component( &quot;myComponent&quot;, MyComponent)</span></span>
<span class="line"><span style="color:#e1e4e8;">const app=new Vue({...})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">import Vue from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#24292e;">import MyComponent from &quot;MyComponent.vue&quot;</span></span>
<span class="line"><span style="color:#24292e;">vue.component( &quot;myComponent&quot;, MyComponent)</span></span>
<span class="line"><span style="color:#24292e;">const app=new Vue({...})</span></span></code></pre></div><p>В Vue 3 вместо этого мы регистрируем компоненты и плагины в приложении <em>после</em> его создания и <em>до</em> его установки. Методы <strong>component</strong> (для компонентов), <strong>use</strong> (для плагинов) и <strong>directive</strong> (для директив) являются цепочечными. Вот как предыдущий пример выглядит в Vue 3:</p><div class="language-source-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">source-code</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">import { createApp }from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">import MyComponent from &quot;MyComponent.vue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">const App=createApp({...})</span></span>
<span class="line"><span style="color:#e1e4e8;">App.component( &quot;myComponent&quot;, MyComponent).mount( &quot;#app&quot;)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">import { createApp }from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#24292e;">import MyComponent from &quot;MyComponent.vue&quot;</span></span>
<span class="line"><span style="color:#24292e;">const App=createApp({...})</span></span>
<span class="line"><span style="color:#24292e;">App.component( &quot;myComponent&quot;, MyComponent).mount( &quot;#app&quot;)</span></span></code></pre></div><p>Если нам не нужно ссылаться на приложение, мы можем просто конкатенировать инстанцию приложения, как в данном примере:</p><div class="language-source-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">source-code</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">import { createApp }from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">import MyComponent from &quot;MyComponent.vue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">createApp({...}).component(&quot;myComponent&quot;, MyComponent) .mount(&quot;#app&quot;)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">import { createApp }from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#24292e;">import MyComponent from &quot;MyComponent.vue&quot;</span></span>
<span class="line"><span style="color:#24292e;">createApp({...}).component(&quot;myComponent&quot;, MyComponent) .mount(&quot;#app&quot;)</span></span></code></pre></div><p>Загрузка приложения не зависит от синтаксиса, используемого для описания компонентов (Options API, Composition API или настройка сценария).</p><h2 id="своиство-data-теперь-всегда-является-функциеи" tabindex="-1">Свойство data теперь всегда является функцией <a class="header-anchor" href="#своиство-data-теперь-всегда-является-функциеи" aria-label="Permalink to &quot;Свойство data теперь всегда является функцией&quot;">​</a></h2><p>.</p><p>В приложениях Vue 2 существует несоответствие в атрибуте <strong>data</strong>. Корневой компонент имеет свойство, которое является непосредственно реактивным определением, в то время как все остальные компоненты должны предоставлять в качестве свойства <strong>data</strong> функцию, возвращающую объект. Это создавало несоответствие при создании компонентов. В Vue 3 эта проблема была решена, и теперь <em>все компоненты рассматриваются одинаково</em>, то есть атрибут data всегда должен быть функцией, возвращающей объект, члены которого будут реактивными свойствами.</p><p>Приведем пример корневого компонента в <span class="No-Break"><strong>main.js</strong></span></p><p>:</p><div class="language-source-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">source-code</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">createApp({</span></span>
<span class="line"><span style="color:#e1e4e8;">     data(){return {...}}</span></span>
<span class="line"><span style="color:#e1e4e8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">createApp({</span></span>
<span class="line"><span style="color:#24292e;">     data(){return {...}}</span></span>
<span class="line"><span style="color:#24292e;">})</span></span></code></pre></div><p>А затем во всех остальных компонентах выполняется следующее:</p><div class="language-source-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">source-code</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">export default {</span></span>
<span class="line"><span style="color:#e1e4e8;">     data(){return {...}}</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">export default {</span></span>
<span class="line"><span style="color:#24292e;">     data(){return {...}}</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>Обратите внимание, что для наглядности в этих примерах мы используем API Options. При использовании синтаксиса <strong>установки скрипта</strong> объявлять атрибут <strong>data</strong></p><p>не требуется.</p><h2 id="больше-реактивных-возможностеи" tabindex="-1">Больше реактивных возможностей <a class="header-anchor" href="#больше-реактивных-возможностеи" aria-label="Permalink to &quot;Больше реактивных возможностей&quot;">​</a></h2><p>.</p><p>При использовании Composition API у нас есть два варианта создания реактивных свойств: <strong>ref()</strong> и <strong>reactive()</strong>. Первая возвращает объект со свойством <strong>.value</strong>, <strong>которое</strong> является реактивным. Вторая преобразует объект, переданный в качестве аргумента, и возвращает тот же объект с реактивными свойствами. Вот один из примеров:</p><div class="language-source-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">source-code</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;script setup&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">import {reactive, ref} from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">const</span></span>
<span class="line"><span style="color:#e1e4e8;">    data=reactive({name: &quot;John&quot;, surname: &quot;Doe&quot;}),</span></span>
<span class="line"><span style="color:#e1e4e8;">    person=ref({name: &quot;Jane&quot;, surname: &quot;Doe&quot;})</span></span>
<span class="line"><span style="color:#e1e4e8;">     // Затем, для доступа к значениям на JavaScript</span></span>
<span class="line"><span style="color:#e1e4e8;">     // Реактивный объект</span></span>
<span class="line"><span style="color:#e1e4e8;">    data.name=&quot;Mary&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">    data.surname=&quot;Sue&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">     // Реактивная ссылка</span></span>
<span class="line"><span style="color:#e1e4e8;">    person.value.name=&quot;Emma&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">    person.value.surname=&quot;Smith&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/script&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;шаблон&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;strong&gt;{{data.surname}}, {{data.name}}&lt;/strong&gt;&lt;br&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">    &lt;strong&gt;{{person.surname}}, {{person.name}}&lt;/strong&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/template&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;script setup&gt;</span></span>
<span class="line"><span style="color:#24292e;">import {reactive, ref} from &quot;vue&quot;</span></span>
<span class="line"><span style="color:#24292e;">const</span></span>
<span class="line"><span style="color:#24292e;">    data=reactive({name: &quot;John&quot;, surname: &quot;Doe&quot;}),</span></span>
<span class="line"><span style="color:#24292e;">    person=ref({name: &quot;Jane&quot;, surname: &quot;Doe&quot;})</span></span>
<span class="line"><span style="color:#24292e;">     // Затем, для доступа к значениям на JavaScript</span></span>
<span class="line"><span style="color:#24292e;">     // Реактивный объект</span></span>
<span class="line"><span style="color:#24292e;">    data.name=&quot;Mary&quot;</span></span>
<span class="line"><span style="color:#24292e;">    data.surname=&quot;Sue&quot;</span></span>
<span class="line"><span style="color:#24292e;">     // Реактивная ссылка</span></span>
<span class="line"><span style="color:#24292e;">    person.value.name=&quot;Emma&quot;</span></span>
<span class="line"><span style="color:#24292e;">    person.value.surname=&quot;Smith&quot;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/script&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;шаблон&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;strong&gt;{{data.surname}}, {{data.name}}&lt;/strong&gt;&lt;br&gt;</span></span>
<span class="line"><span style="color:#24292e;">    &lt;strong&gt;{{person.surname}}, {{person.name}}&lt;/strong&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/template&gt;</span></span></code></pre></div><p>Обратите внимание на разницу в синтаксисе. В этот момент вы можете задуматься, когда использовать то или иное. Вот небольшое сравнение того, когда следует использовать каждый из них:</p><table id="table001-7" class="No-Table-Style _idGenTablePara-1"><tbody><tr class="odd No-Table-Style"><td class="No-Table-Style"><p><strong>ref()</strong></p></td></tr><tr class="even No-Table-Style"><td class="No-Table-Style"><ul><li>Применяется к любому типу данных, не только к примитивам.</li><li>При применении к объектам или массивам их можно заменять.</li><li>Использует геттеры и сеттеры для обнаружения изменений и запуска реактивности.</li><li>Используется по умолчанию для простых данных. Для массивов и объектов (сложных типов) рекомендуется использовать <strong>reactive()</strong> при работе с их внутренними элементами. Если же замене подлежит весь объект, удобно использовать <span class="No-Break"><strong>ref()</strong></span> .</li></ul></td></tr></tbody></table><p>Таблица А.1 - Простое руководство по выбору между ref() и reactive()</p><p>.</p><p>Каждый метод имеет свои преимущества. С точки зрения реактивных свойств со сложными типами не имеет значения, какой из них использовать. В некоторых случаях <strong>reactive()</strong> может быть более производительным за счет использования нативных реализаций в браузере.</p><h2 id="изменения-в-v-model-props-и-events" tabindex="-1">Изменения в v-model, props и events <a class="header-anchor" href="#изменения-в-v-model-props-и-events" aria-label="Permalink to &quot;Изменения в v-model, props и events&quot;">​</a></h2><p>.</p><p>Это большое изменение по сравнению с Vue 2, которое может привести к поломке вашего кода. В Vue 3 мы больше не получаем и не излучаем значение свойства. Вместо этого любой реквизит может быть входным/выходным, например <strong>v-model</strong>. По умолчанию атрибут <strong>v-model</strong> принимается в <em>prop</em> с именем <strong>modelValue</strong>, а аналог <em>emit</em> добавляет <strong>update:</strong>, поэтому он называется <span class="No-Break"><strong>update:modelValue</strong></span><span class="No-Break">. </span></p><p>В Vue 3 появилась возможность одновременного использования нескольких <em>v-моделей</em>. Например, мы можем иметь <strong>v-модель:person=&quot;person&quot;</strong> в нашем компоненте, определить prop как <strong>&quot;modelPerson&quot;</strong> и событие как <span class="No-Break"><strong>&quot;update:modelPerson&quot;</strong></span></p><p>.</p><p>Props class=&quot;No-Break&quot;&gt;.</p><p>Props и emits теперь являются макросами (макрос - это специальная функция, предоставляемая бандлером или фреймворком). <strong>Строки</strong> имеют тот же объем, что и в Vue 2, поэтому их можно определять как массивы, объекты, включаемые типы, значения по умолчанию и т. д.</p><p>Например, в примере с Vue 2.</p><p>Приведем пример с v-моделью по умолчанию и нотированной моделью:</p><div class="language-source-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">source-code</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">const $props=defineProps([&#39;modelValue&#39;,&#39;modelPerson&#39;]),</span></span>
<span class="line"><span style="color:#e1e4e8;">$emit=defineEmits([&#39;update:modelValue&#39;,&#39;update:modelPerson&#39;])</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">const $props=defineProps([&#39;modelValue&#39;,&#39;modelPerson&#39;]),</span></span>
<span class="line"><span style="color:#24292e;">$emit=defineEmits([&#39;update:modelValue&#39;,&#39;update:modelPerson&#39;])</span></span></code></pre></div><p>.</p><p>Более подробно реквизиты и эмиты рассматриваются в этой книге в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_04.xhtml#_idTextAnchor102" target="_blank" rel="noreferrer"><em>главе 4</em></a>, <em>Композиция пользовательского интерфейса</em> <span class="No-Break"><em>с компонентами</em></span></p><p>.</p><h2 id="удалена-совместимость-со-старыми-браузерами" tabindex="-1">Удалена совместимость со старыми браузерами <a class="header-anchor" href="#удалена-совместимость-со-старыми-браузерами" aria-label="Permalink to &quot;Удалена совместимость со старыми браузерами&quot;">​</a></h2><p>.</p><p>Vue 3 был создан для скорости и &quot;современного&quot; JavaScript. Обратная совместимость со старыми браузерами была удалена. Многие внутренние функции, используемые для обеспечения реактивности, теперь по умолчанию используют нативные реализации (например, Proxy API). Если вам необходимо поддерживать приложение в устаревшем браузере, то лучше остановиться на Vue 2, но не стоит бояться! Для Vue 2 существует официальный плагин для использования нового <em>Composition API</em>, включающий <strong>script</strong> <strong>setup</strong></p><p>синтаксис:</p><ul><li>Вue 2.7 включает его без плагинов (<a href="https://blog.vuejs.org/posts/vue-2-7-naruto.html" target="_blank" rel="noreferrer"><span class="No-Break">https://blog.vuejs.org/posts/vue-2-7-naruto.html</span></a> )</li><li>Если вы используете Vue 2.6 или ниже, вы можете найти плагин здесь: <a href="https://github.com/vuejs/composition-api" target="_blank" rel="noreferrer">https://github.com/vuejs/composition-api</a></li><li>Если вам все же нужна скорость Vue 3, существует специальная сборка для миграции, которая имеет практически тот же API, что и Vue 2 (см. <a href="https://v3-migration.vuejs.org/migration-build.html" target="_blank" rel="noreferrer"><span class="No-Break">https://v3-migration.vuejs.org/migration-build.html</span></a> )</li><li>Зачем удалять совместимость со старыми браузерами? На это есть много причин, в том числе следующие: <ul><li>В мире доля использования старых браузеров упала до значительного уровня, и ожидается, что она продолжит снижаться <span class="No-Break">с течением времени.</span></li><li>После удаления старого кода и проверок на совместимость, полученная реализация ядра Vue становится легче и производительнее. Увеличение скорости и уменьшение размера пакета является значительным, что позволяет нашим приложениям загружаться быстрее и быть более отзывчивыми.</li></ul></li></ul><p>На практике большую часть рынка занимают два браузерных движка: браузеры на базе Chromium и браузеры на базе Mozilla Firefox. Проверьте <a href="http://www.caniuse.com/" target="_blank" rel="noreferrer">www.caniuse.com</a>, если вам необходимо использовать функцию, которая может быть недоступна в старых браузерах.</p><h2 id="изменения-в-организации-каталогов-и-фаилов" tabindex="-1">Изменения в организации каталогов и файлов <a class="header-anchor" href="#изменения-в-организации-каталогов-и-фаилов" aria-label="Permalink to &quot;Изменения в организации каталогов и файлов&quot;">​</a></h2><p>На организацию структуры каталогов в Vue 2 в некоторой степени повлияли тогдашний бандлер <strong>WebPack</strong> и <strong>Vue CLI</strong>. Теперь, когда Vue 3 перешел на <strong>Vite</strong>, файлы были организованы таким образом, чтобы лучше отражать рабочий процесс разработки. Так, например, <strong>index.html</strong> переместился в корневую папку из папки <strong>Public/</strong>. Теперь он занимает более заметное место в процессе компоновки. Эти и другие изменения описаны в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_03.xhtml#_idTextAnchor079" target="_blank" rel="noreferrer"><em>главе 3</em></a>, <em>Установка</em> <span class="No-Break"><em>Рабочий проект</em></span></p><p>.</p><h2 id="изменения-в-маршрутизаторе-и-управлении-состояниями" tabindex="-1">Изменения в маршрутизаторе и управлении состояниями <a class="header-anchor" href="#изменения-в-маршрутизаторе-и-управлении-состояниями" aria-label="Permalink to &quot;Изменения в маршрутизаторе и управлении состояниями&quot;">​</a></h2><p>Новый подход к компонентам и модульности также затрагивает маршрутизатор и управление состоянием. В то время как для Vue 3 была разработана новая версия маршрутизатора, официальное решение для управления состоянием перешло от <strong>Vuex</strong> к <strong>Pinia</strong>. Более подробную информацию о новом маршрутизаторе и Pinia можно найти в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130" target="_blank" rel="noreferrer"><em>главе 5</em></a>, <em>Одностраничные приложения</em>, и в <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_07.xhtml#_idTextAnchor173" target="_blank" rel="noreferrer"><span class="No-Break"><em>Глава 7</em></span></a>, <em>Поток данных</em> <span class="No-Break"><em>Управление</em></span></p><p>, соответственно.</p><p>В новом маршрутизаторе реализован иной подход к определению режимов, используются конструкторы <strong>createWebHashHistory</strong> (режим хэша), <strong>createWebHistory</strong> (режим истории) и <strong>createMemoryHistory</strong> (навигация только в памяти). Это изменение также затронуло конфигурацию производственного пакета. В WebPack в режиме истории путь развертывания был частью конфигурации бандлера. Теперь путь передается в конструктор в качестве параметра и полностью обрабатывается маршрутизатором.</p><h2 id="новые-компоненты-и-другие-изменения" tabindex="-1">Новые компоненты и другие изменения <a class="header-anchor" href="#новые-компоненты-и-другие-изменения" aria-label="Permalink to &quot;Новые компоненты и другие изменения&quot;">​</a></h2><p>.</p><p>В Vue 3 также появились новые компоненты, такие как <strong>teleport</strong> (специальный компонент, позволяющий размещать реактивные шаблоны вне дерева компонентов Vue, внутри другого элемента DOM), а также были сняты некоторые ограничения, существовавшие в Vue 2. Например, компоненты теперь могут иметь более одного корневого элемента. Для получения более подробной информации о новых компонентах в Vue 3 обратитесь к официальной документации.</p><h2 id="другие-изменения" tabindex="-1">Другие изменения <a class="header-anchor" href="#другие-изменения" aria-label="Permalink to &quot;Другие изменения&quot;">​</a></h2><p>Полный список изменений, не упомянутых здесь, можно найти в официальной документации по адресу <a href="https://v3-migration.vuejs.org/breaking-changes/" target="_blank" rel="noreferrer"><span class="No-Break">https://v3-migration.vuejs.org/breaking-changes/</span></a></p><p>.</p><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p>Переход с Vue 2 на Vue 3 имеет четкую траекторию, с небольшим количеством изменений, о которых следует знать. Новый API Composition, однако, требует изменения менталитета, но это происходит естественно при использовании синтаксиса <strong>script setup</strong>. Но самая важная особенность Vue 3 - это рост производительности и уменьшение размера. Одним словом, Vue 3 работает быстро, очень быстро, и переход на него стоит того. Для проектов, поддерживающих устаревшие браузеры, существуют плагины для ветви Vue 2.x, которые обеспечивают некоторые преимущества Vue 3, но для других проектов, стремящихся получить положительные результаты от Vue 3, переход на него вполне оправдан.</p><p>.</p>`,84),p=[t];function l(r,c,i,u,m,d){return s(),a("div",null,p)}const y=e(o,[["render",l]]);export{h as __pageData,y as default};
