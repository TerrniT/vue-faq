import{_ as s,c as a,o as i,U as e,a9 as t,aa as l}from"./chunks/framework.OCnj_VtR.js";const y=JSON.parse('{"title":"Полезные советы","description":"","frontmatter":{},"headers":[],"relativePath":"ru/development/misc.md","filePath":"ru/development/misc.md","lastUpdated":1704654181000}'),p={name:"ru/development/misc.md"},n=e(`<h1 id="полезные-советы" tabindex="-1">Полезные советы <a class="header-anchor" href="#полезные-советы" aria-label="Permalink to &quot;Полезные советы&quot;">​</a></h1><details class="details custom-block"><summary>Какие есть хорошие библиотеки для работы с ...?</summary><h3 id="карусель-или-слаидер" tabindex="-1">Карусель или слайдер <a class="header-anchor" href="#карусель-или-слаидер" aria-label="Permalink to &quot;Карусель или слайдер&quot;">​</a></h3><p><a href="https://keen-slider.io/" target="_blank" rel="noreferrer">Keen-Slider</a>, <a href="https://www.embla-carousel.com/" target="_blank" rel="noreferrer">Embla Carousel</a>, <a href="https://splidejs.com/" target="_blank" rel="noreferrer">Splide</a></p><p>Хорошо известный <a href="https://swiperjs.com/" target="_blank" rel="noreferrer">Swiper</a> не очень подходит для Vue.js</p><h3 id="дата-и-время" tabindex="-1">Дата и время <a class="header-anchor" href="#дата-и-время" aria-label="Permalink to &quot;Дата и время&quot;">​</a></h3><p><a href="https://day.js.org/" target="_blank" rel="noreferrer">day.js</a>, <a href="https://date-fns.org/" target="_blank" rel="noreferrer">day-fnc.js</a></p><p>Известный <a href="https://momentjs.com/" target="_blank" rel="noreferrer">moment.js</a> безвозвратно устарел.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Современный JavaScript - это гораздо больше, чем было 10 лет назад. В 95% случаев для операций с датой достаточно возможностей стандартного пакета JavaScript <code>Intl</code></p></div></details><details class="details custom-block"><summary>Как поймать момент когда пользователь доскролил до определенного места?</summary><p>Intersection Observer</p></details><details class="details custom-block"><summary>i18n - интернационализация приложения</summary><p>NPM библиотека для интернационализации и локализации i18n очень популярна, однако за последние годы она сильно располнела. В ней много возможностей для локализации дат, чисел, установки нужных склонений, поддержки RTL языков, загрузки локалей с сервера и кучи еще чего. На сайте i18next она называется уже даже &quot;интернационализационным фреймворком&quot;.</p><p>В то же время часто для локализации сайта в большинстве случаев требуются очень простые вещи, занимающие всего пару процентов от всего функционала тяжеловеса i18n.</p><p>По сути обычно нужна реактивная функция, по ключу и текущей локали возвращающая строку.</p><p>Вариант реализации через композабл - в <a href="https://habr.com/ru/articles/736530/" target="_blank" rel="noreferrer">этой статье</a></p><p>Ваш бандл &quot;похудеет&quot; на 50Кб.</p></details><details class="details custom-block"><summary>Options API или Composition API?</summary><p>Советуется Composition API (script setup) как более логичный и удобный, в котором программист контролирует поток выполнения программы средствами JavaScript, а не просто задает какие-то магические опции.</p></details><details class="details custom-block"><summary>Ref или Reactive?</summary><p>Отличие в плане использования - Reactive работает только с объектами и не отслеживает замену объекта. Ref работает со всем и отслеживает замену переменной:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ x: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// is OK</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// is NOT OK</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { x: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span></code></pre></div><p>Реализации реактивных переменных в Vue 2 и Vue 3 отличаются. Во Vue 2 была своя (фреймворка) реализация отслеживания изменений. Во Vue 3 для этого используется объект Proxy, введенный в ES6. Из-за поддержки данного функционала на уровне языка (JavaScript engine), соответствующий код фреймворка получается эффективней и проще.</p><p>Reactive непосредственно использует Proxy объект.</p><p>Ref на объекте использует напрямую Reactive для отслеживания изменения внутри объекта, и создает и хранит массив зависимостей переменной для примитивов и объектов в случае их замены.</p><p>Если хотите претенциозной эффективности - используйте на объектах Reactive, на примитивах - Ref. В ином случае можно все делать через Ref.</p></details><details class="details custom-block"><summary>Когда использовать Provide/Inject?</summary><h3 id="use-cases" tabindex="-1">Use cases <a class="header-anchor" href="#use-cases" aria-label="Permalink to &quot;Use cases&quot;">​</a></h3><ul><li><p>Настройки темы или конфигурации: Вы можете предоставить глобальные настройки, темы или параметры конфигурации на корневом уровне вашего приложения Vue.js и внедрить их в любой компонент, которому они нужны.</p></li><li><p>Данные аутентификации: Предоставляйте информацию об аутентификации пользователя, например данные пользователя или токены аутентификации, компонентам, которым они необходимы, не передавая их через пропсы.</p></li><li><p>Интернационализация (i18n): Храните данные перевода на корневом уровне и внедряйте их в компоненты, которым требуется отображать текст на разных языках.</p></li><li><p>Тесно связанные компоненты: Например, компонент AccordianPanel, который всегда появляется только внутри слота компонента Accordian. Вы можете инжектировать общие данные, к которым вы всегда хотите иметь доступ, без необходимости передавать их в качестве пропсов.</p></li></ul><h3 id="лучшие-практики-и-соображения" tabindex="-1">Лучшие практики и соображения <a class="header-anchor" href="#лучшие-практики-и-соображения" aria-label="Permalink to &quot;Лучшие практики и соображения&quot;">​</a></h3><p>При использовании provide и inject необходимо помнить о нескольких лучших практиках:</p><ul><li><p>Избегайте чрезмерного использования: Хотя provide и inject могут быть очень мощными, не стоит ими злоупотреблять. Оставьте их для случаев, когда вам действительно нужно поделиться данными между компонентами, не создавая тесной связи между ними.</p></li><li><p>Четкая документация: Документируйте данные, которые вы провайдите и инжектируете, чтобы разработчикам было легко понять, как взаимодействуют компоненты. Их также можно типизировать, - подробности в <a href="https://vuejs.org/guide/typescript/composition-api.html#typing-provide-inject" target="_blank" rel="noreferrer">официальной документации</a>.</p></li><li><p>Рассмотрите возможность Prop Drilling: Prop drilling обычно является антипаттерном, но в некоторых случаях передача данных через пропсы может быть более простым и прозрачным подходом. Оцените, являются ли provide и inject лучшим решением для вашего конкретного сценария.</p></li></ul></details><details class="details custom-block"><summary>ShallowRef</summary><p>Когда у вас массив с большим количеством элементов, но данные внутри элементов массива не меняются, а может меняться только сам массив (добавление элементов, удаление, замена массива) - используйте <code>ShallowRef</code>.</p><p>Он работает как <code>Ref</code>, но не отслеживает изменения внутри элементов массива, что дает значительное улучшение производительности.</p></details><details class="details custom-block"><summary>Миксины</summary><p>Нужно забыть о них как о страшном сне. Миксины как паттерн множественного наследования являются очень плохой архитектурной практикой и должны быть избегаемы. Во Vue 2 в самом фреймворке не было возможности сделать для компонент общей часть стейта и методов, поэтому использовались миксины. Во Vue 3 появилось Composition API и миксины стали не нужны.</p></details><details class="details custom-block"><summary>Pug и Stylus</summary><p>Во Vue экосистеме (включая средства разработки и расширения) данные техноологии плохо поддерживаются и не рекомендуются к использованию.</p></details><details class="details custom-block"><summary>Chrome DevTools custom formatters</summary><p>Google Chrome и некоторые основанные на Chromium браузеры имеют настройку в DevTools в разделе настроек Console - &quot;Enable custom formatters&quot;. После её включения реактивные объекты будут показываться в консоли и в попап-ах при дебаге в более читаемом виде:</p><p><img src="`+t+'" alt=""></p><p>вместо стандартного:</p><p><img src="'+l+`" alt=""></p><p>Временно отключить программно настройку можно так:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> old</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.devtoolsFormatters;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.devtoolsFormatters; </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// will print out data without custom formatting</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.devtoolsFormatters </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> old;</span></span></code></pre></div></details>`,11),r=[n];function o(h,d,k,c,m,u){return i(),a("div",null,r)}const E=s(p,[["render",o]]);export{y as __pageData,E as default};
